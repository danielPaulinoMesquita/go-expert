- to kill all container up. just run the command
docker rm -f $(docker ps -a -q)

- to up docker-compose, run:
sudo docker-compose up -d

- to enter inside the container, you must use:
sudo docker-compose exec goapp bash

- to run a build by GO app
go build .

- to run a build of GO based on Operating System (WINDOWS)
GOOS=windows go build .

- to run build based on architecture
GOOS=linux go build .

- to generate a build (or deploy) defining the name
go build -o server

- to generate to architect linux
GOOS=linux go build -o server .


DWARF - Debugging with arbitrary record format is used to save details about variables, functions and other properties
this will optimize the run command
GOOS=linux go build -ldflags="-w -s" -o server .

Create a image docker file
docker build -t daniel/deploy-k8:latest -f Dockerfile.prod .

To see all images created to docker
- sudo docker images

To see the size of image dockerfile: (if is too big, would be good to optimize that file)
- sudo docker images | grep daniel/deploy-k8

To run a image of docker:
- sudo docker run --rm -p 8080:8080 daniel/deploy-k8:latest

To optimize a file (USING MULTI STADING BUILDING), you will generate the only binary of project go, this features is from Docker, such as "builder" and scratch
basically you separate in steps, the first is builder, it is responsible only for create, and second is scratch, where is placed the minor step, only the binaries.
to make this is necessary change the Dockerfile.prod and after, run again the command:
- docker build -t daniel/deploy-k8:latest -f Dockerfile.prod .


if you try again to run the image, probably will show an error
exec ./server: no such file or directory

And to solve this problem you will need to use the "C GO", this make sure that file doesn't execute external libraries like files in "C"
you have to make a file seem
RUN GOOS=linux CGO_ENABLED=0 go build -ldflags="-w -s" -o server .
by default CGO_enabled is 1
run again the command to build:
- docker build -t daniel/deploy-k8:latest -f Dockerfile.prod .


-- KUBERNETES is manager of containers --------
to create a cluster of kubernetes
visit out https://kind.sigs.k8s.io/

and run to install:
go install sigs.k8s.io/kind@v0.22.0

to create a cluster of k8(kubernetes)
kind create cluster --name=goexpert

to use context of kubernets:
Set kubectl context to "kind-goexpert"
- kubectl cluster-info --context kind-goexpert

if you don't have kubectl yet, you can install acccessing:
https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/

KUBERNETES, works with PODS

to create a pode, execute
kubectl apply -f k8s/deployment.yaml

to see the pods
kubectl get nodes

to add replicas (or other pods) for kubernetes, you can add
replicas: 3

in your file of deployment.yaml (3 represent the amount of replics)

-- SERVICES OF KUBERNETES ---

service make possible the user access the server or pods, you need to create a file yaml named service and put the configurations there

to run command
- kubectl apply -f k8s/service.yaml

to see the services created and running
- kubectl get svc

to test the service and ports of pods, use command of kubectl
- kubectl port-forward svc/serversvc 8080:8080

ATTENTION

You can find errors in your pod, remember the pods try to pull the image of docker hub, so your image needs to be in you docker hub

Regarding the services, you can add LoadBalancer

PROBES FOR KUBERNETES

In the context of Kubernetes and Go (Golang), a probe refers to a mechanism used for health checking of applications running in Kubernetes clusters. Kubernetes provides two types of probes: readiness probes and liveness probes.

Readiness Probe: A readiness probe is used to determine if a container is ready to handle incoming traffic. It indicates whether the application running inside the container is fully initialized and able to accept requests.
If a readiness probe fails, Kubernetes will stop sending traffic to the container until it becomes ready. This is useful to ensure that only healthy containers receive traffic and prevent issues during rolling updates or scaling.

Liveness Probe: A liveness probe is used to determine if a container is still running and functioning properly.
It checks the health of the application inside the container and restarts the container if the probe fails. Liveness probes are used to prevent situations where a container is running but not able to fulfill its intended purpose.

Both readiness and liveness probes can be configured with different types (HTTP, TCP, or Exec) and settings such as the probe's period, timeout, and success criteria.
In Go (Golang), you can implement these probes by defining handlers for specific endpoints or functions that perform the necessary checks and return appropriate responses.